library ieee;
	use ieee.std_logic_1164.all;
	use IEEE.NUMERIC_STD.ALL; --libreria para cambios entre formatos
	use IEEE.MATH_REAL.ALL; --libreria para log2 y ceil

entity Algorimo is
	generic(
		umbral 				: integer :=0;
		cantidad_eventos 	: integer :=256		
	);
	port(
		-- entradas generales
		clk_i										: in	std_logic;
		Start_i,reset_i,leer_i,trigger_i			: in	std_logic;	--leer y trigger son senales externas que le avisan que debe leer los pixeles o reiniciar todo para un nueva img
		-- entradas Capture_input_controller
		pix_cnt_i									: in integer range 0 to 1_310_721;   --cuenta de los pixeles leidos
		pix_data_i 									: in std_logic_vector(7 downto 0);		-- data proveniente de Capture_input_controller
		-- entrada ram energia y cantidad
		energia_i , cantidad_i 					  	: in std_logic_vector(7 downto 0);
		--entrada FIFO
		FIFO_data_i									: in std_logic_vector(integer(ceil(log2(real(cantidad_eventos)))) downto 0);


		-- salidas shift FIFO
		--??
		--salida hacia la FIFO
		FIFO_data_o									: out std_logic_vector (integer(ceil(log2(real(cantidad_eventos)))) downto 0);
		FIFO_dir_o									: out std_logic_vector (10 downto 0); 	--las direcciones necesarias para las 1283 posiciones de memoria
		FIFO_RW_o									: out std_logic;						--se√±al para lectura y escritura de la ram FIFO


		--salida hacia energia y cantidad
		energia_o , cantidad_o 						: out std_logic_vector (7 downto 0);
		--salida control ram de energias y cantidad
		r_w_energia , r_w_cantidad					: out std_logic;
		indice_energias_o , idice_cantidad_o 		: out std_logic_vector (integer(ceil(log2(real(cantidad_eventos)))) downto 0)

	);

end entity;


end architecture ; -- arch

architecture rtl of Algorimo is

	-- Build an enumerated type for the state machine
	type state_type is (nuevo_pix, dir_anterior, dir_ancho_1, dir_ancho_2, dir_ancho_3, lectura_ancho_3, casos, lectura_energia_cantidad, escritura_energia_cantidad, escritura ,decremento_indice_FIFO);

	-- Register to hold the current state
	signal state   		: state_type;

	-- senales internas
	signal indice_FIFO 						: integer range 0 to 2**13-1; --esta variable tiene que tener 13 bits
	signal data_reg 						: std_logic_vector(7 downto 0):=x"00";
	signal indice , FIFO_0 , maximo			: integer range 0 to cantidad_eventos-1;
	signal pix_previo 						: integer range 0 to 1_310_721;
	signal temp_energia , temp_cantidad  	: std_logic_vector(7 downto 0):=x"00";	
begin

	-- Logic to advance to the next state
	process (clk, reset) 
	begin
		if reset = '0' then
			state <= nuevo_pix;
			pix_previo <= 0;
			data_reg <= (others => '0' );
			indice<= 1283;
		elsif (rising_edge(clk)) then
			case state is
				when nuevo_pix=>
					if pix_cnt_i /= pix_previo then  					-- si el la cuenta de pixel es distinta a la cuenta anterior, el pixel es nuevo
						pix_previo<=pix_cnt_i;							-- actualizamos el pixel_previo
						if to_integer(unsigned(pix_data)) > umbral then --comparacion con el umbral
							data_reg<=pix_data;							-- si supera el umbral guardamos la data del pixel
							state<=dir_anterior;						-- tenemos que rescatar los valores de al rededor del nuevo pixel
							maximo<=0;
						else
							FIFO_0 <= 0;								-- mandamos un cero para el FIFO_0 asi le mandamos un 0 a la fifo desp
							state<= escritura;							-- si no supera el umbral hacemos el shift nomas
						end if;	
					else
						state <= nuevo_pix;								-- si no es un nuevo pixel esperamos un nuevo pixel
					end if;
				when dir_anterior =>							--presentacion de la dir de memoria que contiene el pixel anterior
					if indice_FIFO+1 >= 1283 then
						FIFO_dir_o <= std_logic_vector(to_unsigned(indice_FIFO+1-1283,indice_FIFO'length)); 	-- si es mayor a 1283 entonces le tengo que restar 1283 a la direccion +1 entonces completo
																											-- seria indice_FIFO+1-1283=indice_FIFO-1282 , despues el dato lo leemos en el proximo estado
																											-- asi le damos 1 ciclo de reloj para responder a la memoria																					-- reloj para que me pueda dar la data;
					else
						FIFO_dir_o <= std_logic_vector(to_unsigned(indice_FIFO+1,indice_FIFO'length));
					end if;
					state <= dir_ancho_1;
				when dir_ancho_1 =>								--presentacion de la dir de memoria que tiene el pixel en ancho+1 y lectura pixel anterior
					if indice_FIFO+1280 >= 1283 then
						FIFO_dir_o <= std_logic_vector(to_unsigned(indice_FIFO+1280-1283,indice_FIFO'length)); 	-- si es mayor a 1283 entonces le tengo que restar 1283 a la direcion + 1280
																											-- despues el dato lo leemos en el proximo estado
																											-- asi le damos 1 ciclo de reloj para responder a la memoria																					-- reloj para que me pueda dar la data;
					else
						FIFO_dir_o <= std_logic_vector(to_unsigned(indice_FIFO+1280,indice_FIFO'length));
					end if;
					state <= dir_ancho_2;
				when dir_ancho_2 =>								--presentacion de la dir de memoria que tiene el pixel en ancho+2 y lectura pixel ancho + 1
					if indice_FIFO+1281 >= 1283 then
						FIFO_dir_o <= std_logic_vector(to_unsigned(indice_FIFO+1281-1283,indice_FIFO'length)); 	-- si es mayor a 1283 entonces le tengo que restar 1283 a la direcion + 1280
																											-- despues el dato lo leemos en el proximo estado
																											-- asi le damos 1 ciclo de reloj para responder a la memoria																					-- reloj para que me pueda dar la data;
					else
						FIFO_dir_o <= std_logic_vector(to_unsigned(indice_FIFO+1281,indice_FIFO'length));
					end if;
					state <= dir_ancho_3;
				when dir_ancho_3 =>								--presentacion de la dir de memoria que tiene el pixel en ancho+3 y lectura pixel ancho + 2
					if indice_FIFO+1282 >= 1283 then
						FIFO_dir_o <= std_logic_vector(to_unsigned(indice_FIFO+1282-1283,indice_FIFO'length)); 	-- si es mayor a 1283 entonces le tengo que restar 1283 a la direcion + 1280
																											-- despues el dato lo leemos en el proximo estado
																											-- asi le damos 1 ciclo de reloj para responder a la memoria																					-- reloj para que me pueda dar la data;
					else
						FIFO_dir_o <= std_logic_vector(to_unsigned(indice_FIFO+1282,indice_FIFO'length));
					end if;
					state <= lectura_ancho_3;
				when lectura_ancho_3 => 						-- en este estado leemos la info que esta en ancho +3 no deberia hacer nada mas
					state<= casos;								-- con el dato anterior, ancho+1, ancho+2 y ancho+3 ya podemos ver los casos
				when casos=>											--EN ESTE ESTADO VEMOS EL INDICE que son los datos dentro de la FIFO
					if to_integer(unsigned(reg_FIFO_1))=0 and to_integer(unsigned(reg_ancho_1))=0 and to_integer(unsigned(reg_ancho_2))=0 and to_integer(unsigned(reg_ancho_3))=0  then --nuevo evento
						FIFO_0 <= indice;								-- le asignamos el num de indice(evento) al, FIFO y lo aumentamos
						indice <= indice + 1; 							-- aumentamos el numero de evento
					else
						maximo <= reg_FIFO_1;
						if reg_ancho_1 > maximo then
							maximo <= reg_ancho_1;
						end if;
						if reg_ancho_2 > maximo then
							maximo <= reg_ancho_2;
						end if;
						if reg_ancho_3 > maximo then
							maximo <= reg_ancho_3;
						end if;
						FIFO_0 <= maximo;  								-- esto no estoy seguro de si va a ser en paralelo o secuencial
																		-- pero la idea es la misma que me busque cual es el indice maximo y se lo aplique a FIFO_0
					end if;
					state<= lectura_energia_cantidad;
				when lectura_energia_cantidad =>								-- EN ESTE ESTADO ESCRIBIMOS LAS MEMORIAS RAM
					indice_energias_o <= std_logic_vector(to_unsigned(FIFO_0, FIFO_0'length));
					indice_cantidad_o <= std_logic_vector(to_unsigned(FIFO_0, FIFO_0'length));	-- les mandamos el indice como direccion de memoria a las RAM
					temp_energia <= energia_i;
					temp_cantidad <= cantidad_i;
					state <= escritura_energia_cantidad;
				when escritura_energia_cantidad =>
					indice_energias_o <= std_logic_vector(to_unsigned(FIFO_0, FIFO_0'length));
					indice_cantidad_o <= std_logic_vector(to_unsigned(FIFO_0, FIFO_0'length));	-- les mandamos el indice como direccion de memoria a las RAM
					energia_o <= std_logic_vector(unsigned(temp_energia) + unsigned(data_reg));	-- le sumamos la energia del nuevo pixel
					cantidad_o <= std_logic_vector(unsigned(temp_cantidad) + 1) ;				-- le sumamos 1 a la cantidad de pixeles que tiene la mancha
					state <= escritura;
				when escritura =>								--estado encargado de escribir la RAM FIFO
					--FIFO_data_o <= FIFO_0;
					FIFO_dir_o <= indice_FIFO;
					state<=decremento_indice_FIFO;
				when decremento_indice_FIFO =>
					indice_FIFO <= indice_FIFO - 1;
					if indice_FIFO < 0  then
						indice_FIFO <= 1282;
					end if ;
					state <= nuevo_pix;
			end case;
		end if;
	end process;

	-- Output depends solely on the current state
	process (state)
	begin
		case state is
			when nuevo_pix =>
				--salida hacia la FIFO
				FIFO_0_o<=??;
			when casos =>
				output <= "01";
			when lectura_energia_cantidad =>
				output <= "10";
			when escritura_energia_cantidad =>
				output <= "11";
			when shift =>
				shift_dale<='1'; -- place holder
		end case;
	end process;

end rtl;
