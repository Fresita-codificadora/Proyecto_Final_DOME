-- Quartus Prime VHDL Template
-- Four-State Moore State Machine

-- A Moore machine's outputs are dependent only on the current state.
-- The output is written only when the state changes.  (State
-- transitions are synchronous.)

library ieee;
use ieee.std_logic_1164.all;

entity programador is

	port(
		--variables unicamente necesarias para la simulacion 
		clk_div8_sim : out std_logic;
		--variables necesarias		
		clk		 : in	std_logic;	
		s_t	 : in	std_logic; --start input
		r_w : in std_logic;
		--stop : in std_logic; no se si es necesaria
		reset	 : in	std_logic;
		data : in std_logic_vector (7 downto 0);
		sda	 : inout	std_logic;
		sca    : out std_logic;
		buisy : out std_logic 
	);

end entity;

architecture rtl of programador is

	-- Build an enumerated type for the state machine
	type state_type is (idle, start, b_trans, b_write,ack_1,ack_2,error,idle_2,stop_1,stop_2);

	-- Register to hold the current state
	signal state   : state_type;
	signal bitcount: integer range 0 to 8;
	signal clk_div2,clk_div4,clk_div8 : std_logic;

begin
	clk_div2 <= not(clk_div2) when (clk'event and clk='1');
	clk_div4 <= not(clk_div4) when (clk_div2'event and clk_div2='1');--generador del clk 
	clk_div8 <= not(clk_div4) when (clk_div4'event and clk_div4='1');
	clk_div8_sim<=clk_div8;
	-- Logic to advance to the next state
	process (clk_div8, reset)
	begin
		if reset = '1' then
			state <= idle;
		elsif (rising_edge(clk_div8)) then
			case state is
				when idle=>
					if s_t = '1' then
						state <= start;
					else
						state <= idle;
					end if;
					
				when start=>
					count <= 7;
					state <= b_trans;
				
				when b_trans=>
					state <= b_write;
				
				when b_write =>
					if count-1>=0 then
						state <= b_trans;
					else 
						count <= 7;
						state <= ack_1;
					end if;
				
				when ack_1 =>
					state <= ack_2;
				
				when ack_2 =>
					if sda='1' then
						state <= error;
					else
						state <= idle_2;
					end if;
				
				when idle_2 =>
					if r_w = '1' then
						state <= b_trans;
					elsif stop = '1' then
						state <= stop_1;
					else
						state <= idle_2;
					end if;
				
				when stop_1 =>
					state <= stop_2;
				
				when stop_2 =>
					state <= idle;
					
			end case;
		end if;
	end process;

	-- Output depends solely on the current state
	process (state)
	begin
		case state is
			when idle =>
				output <= "00";
			when start =>
				output <= "01";
			when b_trans =>
				output <= "10";
			when b_write =>
				output <= "11";
		end case;
	end process;

end rtl;
